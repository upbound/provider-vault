//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraInitParameters) DeepCopyInto(out *CassandraInitParameters) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraInitParameters.
func (in *CassandraInitParameters) DeepCopy() *CassandraInitParameters {
	if in == nil {
		return nil
	}
	out := new(CassandraInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraObservation) DeepCopyInto(out *CassandraObservation) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraObservation.
func (in *CassandraObservation) DeepCopy() *CassandraObservation {
	if in == nil {
		return nil
	}
	out := new(CassandraObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraParameters) DeepCopyInto(out *CassandraParameters) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemBundleSecretRef != nil {
		in, out := &in.PemBundleSecretRef, &out.PemBundleSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemJSONSecretRef != nil {
		in, out := &in.PemJSONSecretRef, &out.PemJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraParameters.
func (in *CassandraParameters) DeepCopy() *CassandraParameters {
	if in == nil {
		return nil
	}
	out := new(CassandraParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CouchbaseInitParameters) DeepCopyInto(out *CouchbaseInitParameters) {
	*out = *in
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CouchbaseInitParameters.
func (in *CouchbaseInitParameters) DeepCopy() *CouchbaseInitParameters {
	if in == nil {
		return nil
	}
	out := new(CouchbaseInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CouchbaseObservation) DeepCopyInto(out *CouchbaseObservation) {
	*out = *in
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CouchbaseObservation.
func (in *CouchbaseObservation) DeepCopy() *CouchbaseObservation {
	if in == nil {
		return nil
	}
	out := new(CouchbaseObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CouchbaseParameters) DeepCopyInto(out *CouchbaseParameters) {
	*out = *in
	if in.Base64PemSecretRef != nil {
		in, out := &in.Base64PemSecretRef, &out.Base64PemSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CouchbaseParameters.
func (in *CouchbaseParameters) DeepCopy() *CouchbaseParameters {
	if in == nil {
		return nil
	}
	out := new(CouchbaseParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchInitParameters) DeepCopyInto(out *ElasticsearchInitParameters) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchInitParameters.
func (in *ElasticsearchInitParameters) DeepCopy() *ElasticsearchInitParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchObservation) DeepCopyInto(out *ElasticsearchObservation) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchObservation.
func (in *ElasticsearchObservation) DeepCopy() *ElasticsearchObservation {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchParameters) DeepCopyInto(out *ElasticsearchParameters) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchParameters.
func (in *ElasticsearchParameters) DeepCopy() *ElasticsearchParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HanaInitParameters) DeepCopyInto(out *HanaInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HanaInitParameters.
func (in *HanaInitParameters) DeepCopy() *HanaInitParameters {
	if in == nil {
		return nil
	}
	out := new(HanaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HanaObservation) DeepCopyInto(out *HanaObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HanaObservation.
func (in *HanaObservation) DeepCopy() *HanaObservation {
	if in == nil {
		return nil
	}
	out := new(HanaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HanaParameters) DeepCopyInto(out *HanaParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HanaParameters.
func (in *HanaParameters) DeepCopy() *HanaParameters {
	if in == nil {
		return nil
	}
	out := new(HanaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfluxdbInitParameters) DeepCopyInto(out *InfluxdbInitParameters) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfluxdbInitParameters.
func (in *InfluxdbInitParameters) DeepCopy() *InfluxdbInitParameters {
	if in == nil {
		return nil
	}
	out := new(InfluxdbInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfluxdbObservation) DeepCopyInto(out *InfluxdbObservation) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfluxdbObservation.
func (in *InfluxdbObservation) DeepCopy() *InfluxdbObservation {
	if in == nil {
		return nil
	}
	out := new(InfluxdbObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfluxdbParameters) DeepCopyInto(out *InfluxdbParameters) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.PemBundleSecretRef != nil {
		in, out := &in.PemBundleSecretRef, &out.PemBundleSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemJSONSecretRef != nil {
		in, out := &in.PemJSONSecretRef, &out.PemJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfluxdbParameters.
func (in *InfluxdbParameters) DeepCopy() *InfluxdbParameters {
	if in == nil {
		return nil
	}
	out := new(InfluxdbParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbInitParameters) DeepCopyInto(out *MongodbInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbInitParameters.
func (in *MongodbInitParameters) DeepCopy() *MongodbInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbObservation) DeepCopyInto(out *MongodbObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbObservation.
func (in *MongodbObservation) DeepCopy() *MongodbObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbParameters) DeepCopyInto(out *MongodbParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbParameters.
func (in *MongodbParameters) DeepCopy() *MongodbParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbatlasInitParameters) DeepCopyInto(out *MongodbatlasInitParameters) {
	*out = *in
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbatlasInitParameters.
func (in *MongodbatlasInitParameters) DeepCopy() *MongodbatlasInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbatlasInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbatlasObservation) DeepCopyInto(out *MongodbatlasObservation) {
	*out = *in
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbatlasObservation.
func (in *MongodbatlasObservation) DeepCopy() *MongodbatlasObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbatlasObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbatlasParameters) DeepCopyInto(out *MongodbatlasParameters) {
	*out = *in
	out.PrivateKeySecretRef = in.PrivateKeySecretRef
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbatlasParameters.
func (in *MongodbatlasParameters) DeepCopy() *MongodbatlasParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbatlasParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MssqlInitParameters) DeepCopyInto(out *MssqlInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MssqlInitParameters.
func (in *MssqlInitParameters) DeepCopy() *MssqlInitParameters {
	if in == nil {
		return nil
	}
	out := new(MssqlInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MssqlObservation) DeepCopyInto(out *MssqlObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MssqlObservation.
func (in *MssqlObservation) DeepCopy() *MssqlObservation {
	if in == nil {
		return nil
	}
	out := new(MssqlObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MssqlParameters) DeepCopyInto(out *MssqlParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MssqlParameters.
func (in *MssqlParameters) DeepCopy() *MssqlParameters {
	if in == nil {
		return nil
	}
	out := new(MssqlParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLAuroraInitParameters) DeepCopyInto(out *MySQLAuroraInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLAuroraInitParameters.
func (in *MySQLAuroraInitParameters) DeepCopy() *MySQLAuroraInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLAuroraInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLAuroraObservation) DeepCopyInto(out *MySQLAuroraObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLAuroraObservation.
func (in *MySQLAuroraObservation) DeepCopy() *MySQLAuroraObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLAuroraObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLAuroraParameters) DeepCopyInto(out *MySQLAuroraParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLAuroraParameters.
func (in *MySQLAuroraParameters) DeepCopy() *MySQLAuroraParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLAuroraParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLInitParameters) DeepCopyInto(out *MySQLInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLInitParameters.
func (in *MySQLInitParameters) DeepCopy() *MySQLInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLegacyInitParameters) DeepCopyInto(out *MySQLLegacyInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLegacyInitParameters.
func (in *MySQLLegacyInitParameters) DeepCopy() *MySQLLegacyInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLLegacyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLegacyObservation) DeepCopyInto(out *MySQLLegacyObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLegacyObservation.
func (in *MySQLLegacyObservation) DeepCopy() *MySQLLegacyObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLLegacyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLegacyParameters) DeepCopyInto(out *MySQLLegacyParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLegacyParameters.
func (in *MySQLLegacyParameters) DeepCopy() *MySQLLegacyParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLLegacyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLObservation) DeepCopyInto(out *MySQLObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLObservation.
func (in *MySQLObservation) DeepCopy() *MySQLObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLParameters) DeepCopyInto(out *MySQLParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLParameters.
func (in *MySQLParameters) DeepCopy() *MySQLParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLRDSInitParameters) DeepCopyInto(out *MySQLRDSInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLRDSInitParameters.
func (in *MySQLRDSInitParameters) DeepCopy() *MySQLRDSInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLRDSInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLRDSObservation) DeepCopyInto(out *MySQLRDSObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLRDSObservation.
func (in *MySQLRDSObservation) DeepCopy() *MySQLRDSObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLRDSObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLRDSParameters) DeepCopyInto(out *MySQLRDSParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLRDSParameters.
func (in *MySQLRDSParameters) DeepCopy() *MySQLRDSParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLRDSParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OracleInitParameters) DeepCopyInto(out *OracleInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OracleInitParameters.
func (in *OracleInitParameters) DeepCopy() *OracleInitParameters {
	if in == nil {
		return nil
	}
	out := new(OracleInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OracleObservation) DeepCopyInto(out *OracleObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OracleObservation.
func (in *OracleObservation) DeepCopy() *OracleObservation {
	if in == nil {
		return nil
	}
	out := new(OracleObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OracleParameters) DeepCopyInto(out *OracleParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OracleParameters.
func (in *OracleParameters) DeepCopy() *OracleParameters {
	if in == nil {
		return nil
	}
	out := new(OracleParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgresqlInitParameters) DeepCopyInto(out *PostgresqlInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgresqlInitParameters.
func (in *PostgresqlInitParameters) DeepCopy() *PostgresqlInitParameters {
	if in == nil {
		return nil
	}
	out := new(PostgresqlInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgresqlObservation) DeepCopyInto(out *PostgresqlObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgresqlObservation.
func (in *PostgresqlObservation) DeepCopy() *PostgresqlObservation {
	if in == nil {
		return nil
	}
	out := new(PostgresqlObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgresqlParameters) DeepCopyInto(out *PostgresqlParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgresqlParameters.
func (in *PostgresqlParameters) DeepCopy() *PostgresqlParameters {
	if in == nil {
		return nil
	}
	out := new(PostgresqlParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisElasticacheInitParameters) DeepCopyInto(out *RedisElasticacheInitParameters) {
	*out = *in
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisElasticacheInitParameters.
func (in *RedisElasticacheInitParameters) DeepCopy() *RedisElasticacheInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisElasticacheInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisElasticacheObservation) DeepCopyInto(out *RedisElasticacheObservation) {
	*out = *in
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisElasticacheObservation.
func (in *RedisElasticacheObservation) DeepCopy() *RedisElasticacheObservation {
	if in == nil {
		return nil
	}
	out := new(RedisElasticacheObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisElasticacheParameters) DeepCopyInto(out *RedisElasticacheParameters) {
	*out = *in
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UsernameSecretRef != nil {
		in, out := &in.UsernameSecretRef, &out.UsernameSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisElasticacheParameters.
func (in *RedisElasticacheParameters) DeepCopy() *RedisElasticacheParameters {
	if in == nil {
		return nil
	}
	out := new(RedisElasticacheParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisInitParameters) DeepCopyInto(out *RedisInitParameters) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisInitParameters.
func (in *RedisInitParameters) DeepCopy() *RedisInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisObservation) DeepCopyInto(out *RedisObservation) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisObservation.
func (in *RedisObservation) DeepCopy() *RedisObservation {
	if in == nil {
		return nil
	}
	out := new(RedisObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisParameters) DeepCopyInto(out *RedisParameters) {
	*out = *in
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisParameters.
func (in *RedisParameters) DeepCopy() *RedisParameters {
	if in == nil {
		return nil
	}
	out := new(RedisParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftInitParameters) DeepCopyInto(out *RedshiftInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftInitParameters.
func (in *RedshiftInitParameters) DeepCopy() *RedshiftInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedshiftInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftObservation) DeepCopyInto(out *RedshiftObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftObservation.
func (in *RedshiftObservation) DeepCopy() *RedshiftObservation {
	if in == nil {
		return nil
	}
	out := new(RedshiftObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftParameters) DeepCopyInto(out *RedshiftParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftParameters.
func (in *RedshiftParameters) DeepCopy() *RedshiftParameters {
	if in == nil {
		return nil
	}
	out := new(RedshiftParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnection) DeepCopyInto(out *SecretBackendConnection) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnection.
func (in *SecretBackendConnection) DeepCopy() *SecretBackendConnection {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnection)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendConnection) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionInitParameters) DeepCopyInto(out *SecretBackendConnectionInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]CassandraInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]CouchbaseInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]HanaInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]InfluxdbInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]MongodbatlasInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]MssqlInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]MySQLAuroraInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]MySQLLegacyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]MySQLRDSInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]OracleInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]PostgresqlInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]RedisElasticacheInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]RedshiftInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SnowflakeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionInitParameters.
func (in *SecretBackendConnectionInitParameters) DeepCopy() *SecretBackendConnectionInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionList) DeepCopyInto(out *SecretBackendConnectionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SecretBackendConnection, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionList.
func (in *SecretBackendConnectionList) DeepCopy() *SecretBackendConnectionList {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendConnectionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionObservation) DeepCopyInto(out *SecretBackendConnectionObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]CassandraObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]CouchbaseObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]HanaObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]InfluxdbObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]MongodbatlasObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]MssqlObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]MySQLAuroraObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]MySQLLegacyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]MySQLRDSObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]OracleObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]PostgresqlObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]RedisElasticacheObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]RedshiftObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SnowflakeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionObservation.
func (in *SecretBackendConnectionObservation) DeepCopy() *SecretBackendConnectionObservation {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionParameters) DeepCopyInto(out *SecretBackendConnectionParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]CassandraParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]CouchbaseParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]HanaParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]InfluxdbParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]MongodbatlasParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]MssqlParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]MySQLAuroraParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]MySQLLegacyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]MySQLRDSParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]OracleParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]PostgresqlParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]RedisElasticacheParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]RedshiftParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SnowflakeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionParameters.
func (in *SecretBackendConnectionParameters) DeepCopy() *SecretBackendConnectionParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionSpec) DeepCopyInto(out *SecretBackendConnectionSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionSpec.
func (in *SecretBackendConnectionSpec) DeepCopy() *SecretBackendConnectionSpec {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendConnectionStatus) DeepCopyInto(out *SecretBackendConnectionStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendConnectionStatus.
func (in *SecretBackendConnectionStatus) DeepCopy() *SecretBackendConnectionStatus {
	if in == nil {
		return nil
	}
	out := new(SecretBackendConnectionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRole) DeepCopyInto(out *SecretBackendRole) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRole.
func (in *SecretBackendRole) DeepCopy() *SecretBackendRole {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRole)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendRole) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleInitParameters) DeepCopyInto(out *SecretBackendRoleInitParameters) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.CreationStatements != nil {
		in, out := &in.CreationStatements, &out.CreationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CredentialConfig != nil {
		in, out := &in.CredentialConfig, &out.CredentialConfig
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CredentialType != nil {
		in, out := &in.CredentialType, &out.CredentialType
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.DefaultTTL != nil {
		in, out := &in.DefaultTTL, &out.DefaultTTL
		*out = new(float64)
		**out = **in
	}
	if in.MaxTTL != nil {
		in, out := &in.MaxTTL, &out.MaxTTL
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RenewStatements != nil {
		in, out := &in.RenewStatements, &out.RenewStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RevocationStatements != nil {
		in, out := &in.RevocationStatements, &out.RevocationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RollbackStatements != nil {
		in, out := &in.RollbackStatements, &out.RollbackStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleInitParameters.
func (in *SecretBackendRoleInitParameters) DeepCopy() *SecretBackendRoleInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleList) DeepCopyInto(out *SecretBackendRoleList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SecretBackendRole, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleList.
func (in *SecretBackendRoleList) DeepCopy() *SecretBackendRoleList {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendRoleList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleObservation) DeepCopyInto(out *SecretBackendRoleObservation) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.CreationStatements != nil {
		in, out := &in.CreationStatements, &out.CreationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CredentialConfig != nil {
		in, out := &in.CredentialConfig, &out.CredentialConfig
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CredentialType != nil {
		in, out := &in.CredentialType, &out.CredentialType
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.DefaultTTL != nil {
		in, out := &in.DefaultTTL, &out.DefaultTTL
		*out = new(float64)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.MaxTTL != nil {
		in, out := &in.MaxTTL, &out.MaxTTL
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RenewStatements != nil {
		in, out := &in.RenewStatements, &out.RenewStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RevocationStatements != nil {
		in, out := &in.RevocationStatements, &out.RevocationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RollbackStatements != nil {
		in, out := &in.RollbackStatements, &out.RollbackStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleObservation.
func (in *SecretBackendRoleObservation) DeepCopy() *SecretBackendRoleObservation {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleParameters) DeepCopyInto(out *SecretBackendRoleParameters) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.CreationStatements != nil {
		in, out := &in.CreationStatements, &out.CreationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CredentialConfig != nil {
		in, out := &in.CredentialConfig, &out.CredentialConfig
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CredentialType != nil {
		in, out := &in.CredentialType, &out.CredentialType
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.DefaultTTL != nil {
		in, out := &in.DefaultTTL, &out.DefaultTTL
		*out = new(float64)
		**out = **in
	}
	if in.MaxTTL != nil {
		in, out := &in.MaxTTL, &out.MaxTTL
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RenewStatements != nil {
		in, out := &in.RenewStatements, &out.RenewStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RevocationStatements != nil {
		in, out := &in.RevocationStatements, &out.RevocationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RollbackStatements != nil {
		in, out := &in.RollbackStatements, &out.RollbackStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleParameters.
func (in *SecretBackendRoleParameters) DeepCopy() *SecretBackendRoleParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleSpec) DeepCopyInto(out *SecretBackendRoleSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleSpec.
func (in *SecretBackendRoleSpec) DeepCopy() *SecretBackendRoleSpec {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendRoleStatus) DeepCopyInto(out *SecretBackendRoleStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendRoleStatus.
func (in *SecretBackendRoleStatus) DeepCopy() *SecretBackendRoleStatus {
	if in == nil {
		return nil
	}
	out := new(SecretBackendRoleStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRole) DeepCopyInto(out *SecretBackendStaticRole) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRole.
func (in *SecretBackendStaticRole) DeepCopy() *SecretBackendStaticRole {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRole)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendStaticRole) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleInitParameters) DeepCopyInto(out *SecretBackendStaticRoleInitParameters) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RotationPeriod != nil {
		in, out := &in.RotationPeriod, &out.RotationPeriod
		*out = new(float64)
		**out = **in
	}
	if in.RotationSchedule != nil {
		in, out := &in.RotationSchedule, &out.RotationSchedule
		*out = new(string)
		**out = **in
	}
	if in.RotationStatements != nil {
		in, out := &in.RotationStatements, &out.RotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RotationWindow != nil {
		in, out := &in.RotationWindow, &out.RotationWindow
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleInitParameters.
func (in *SecretBackendStaticRoleInitParameters) DeepCopy() *SecretBackendStaticRoleInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleList) DeepCopyInto(out *SecretBackendStaticRoleList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SecretBackendStaticRole, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleList.
func (in *SecretBackendStaticRoleList) DeepCopy() *SecretBackendStaticRoleList {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretBackendStaticRoleList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleObservation) DeepCopyInto(out *SecretBackendStaticRoleObservation) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RotationPeriod != nil {
		in, out := &in.RotationPeriod, &out.RotationPeriod
		*out = new(float64)
		**out = **in
	}
	if in.RotationSchedule != nil {
		in, out := &in.RotationSchedule, &out.RotationSchedule
		*out = new(string)
		**out = **in
	}
	if in.RotationStatements != nil {
		in, out := &in.RotationStatements, &out.RotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RotationWindow != nil {
		in, out := &in.RotationWindow, &out.RotationWindow
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleObservation.
func (in *SecretBackendStaticRoleObservation) DeepCopy() *SecretBackendStaticRoleObservation {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleParameters) DeepCopyInto(out *SecretBackendStaticRoleParameters) {
	*out = *in
	if in.Backend != nil {
		in, out := &in.Backend, &out.Backend
		*out = new(string)
		**out = **in
	}
	if in.DBName != nil {
		in, out := &in.DBName, &out.DBName
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.RotationPeriod != nil {
		in, out := &in.RotationPeriod, &out.RotationPeriod
		*out = new(float64)
		**out = **in
	}
	if in.RotationSchedule != nil {
		in, out := &in.RotationSchedule, &out.RotationSchedule
		*out = new(string)
		**out = **in
	}
	if in.RotationStatements != nil {
		in, out := &in.RotationStatements, &out.RotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RotationWindow != nil {
		in, out := &in.RotationWindow, &out.RotationWindow
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleParameters.
func (in *SecretBackendStaticRoleParameters) DeepCopy() *SecretBackendStaticRoleParameters {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleSpec) DeepCopyInto(out *SecretBackendStaticRoleSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleSpec.
func (in *SecretBackendStaticRoleSpec) DeepCopy() *SecretBackendStaticRoleSpec {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretBackendStaticRoleStatus) DeepCopyInto(out *SecretBackendStaticRoleStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretBackendStaticRoleStatus.
func (in *SecretBackendStaticRoleStatus) DeepCopy() *SecretBackendStaticRoleStatus {
	if in == nil {
		return nil
	}
	out := new(SecretBackendStaticRoleStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMount) DeepCopyInto(out *SecretsMount) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMount.
func (in *SecretsMount) DeepCopy() *SecretsMount {
	if in == nil {
		return nil
	}
	out := new(SecretsMount)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretsMount) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCassandraInitParameters) DeepCopyInto(out *SecretsMountCassandraInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCassandraInitParameters.
func (in *SecretsMountCassandraInitParameters) DeepCopy() *SecretsMountCassandraInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCassandraInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCassandraObservation) DeepCopyInto(out *SecretsMountCassandraObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCassandraObservation.
func (in *SecretsMountCassandraObservation) DeepCopy() *SecretsMountCassandraObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCassandraObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCassandraParameters) DeepCopyInto(out *SecretsMountCassandraParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemBundleSecretRef != nil {
		in, out := &in.PemBundleSecretRef, &out.PemBundleSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemJSONSecretRef != nil {
		in, out := &in.PemJSONSecretRef, &out.PemJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.ProtocolVersion != nil {
		in, out := &in.ProtocolVersion, &out.ProtocolVersion
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCassandraParameters.
func (in *SecretsMountCassandraParameters) DeepCopy() *SecretsMountCassandraParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCassandraParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCouchbaseInitParameters) DeepCopyInto(out *SecretsMountCouchbaseInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCouchbaseInitParameters.
func (in *SecretsMountCouchbaseInitParameters) DeepCopy() *SecretsMountCouchbaseInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCouchbaseInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCouchbaseObservation) DeepCopyInto(out *SecretsMountCouchbaseObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCouchbaseObservation.
func (in *SecretsMountCouchbaseObservation) DeepCopy() *SecretsMountCouchbaseObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCouchbaseObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountCouchbaseParameters) DeepCopyInto(out *SecretsMountCouchbaseParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Base64PemSecretRef != nil {
		in, out := &in.Base64PemSecretRef, &out.Base64PemSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountCouchbaseParameters.
func (in *SecretsMountCouchbaseParameters) DeepCopy() *SecretsMountCouchbaseParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountCouchbaseParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountElasticsearchInitParameters) DeepCopyInto(out *SecretsMountElasticsearchInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountElasticsearchInitParameters.
func (in *SecretsMountElasticsearchInitParameters) DeepCopy() *SecretsMountElasticsearchInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountElasticsearchInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountElasticsearchObservation) DeepCopyInto(out *SecretsMountElasticsearchObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountElasticsearchObservation.
func (in *SecretsMountElasticsearchObservation) DeepCopy() *SecretsMountElasticsearchObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountElasticsearchObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountElasticsearchParameters) DeepCopyInto(out *SecretsMountElasticsearchParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.CAPath != nil {
		in, out := &in.CAPath, &out.CAPath
		*out = new(string)
		**out = **in
	}
	if in.ClientCert != nil {
		in, out := &in.ClientCert, &out.ClientCert
		*out = new(string)
		**out = **in
	}
	if in.ClientKey != nil {
		in, out := &in.ClientKey, &out.ClientKey
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Insecure != nil {
		in, out := &in.Insecure, &out.Insecure
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSServerName != nil {
		in, out := &in.TLSServerName, &out.TLSServerName
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountElasticsearchParameters.
func (in *SecretsMountElasticsearchParameters) DeepCopy() *SecretsMountElasticsearchParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountElasticsearchParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountHanaInitParameters) DeepCopyInto(out *SecretsMountHanaInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountHanaInitParameters.
func (in *SecretsMountHanaInitParameters) DeepCopy() *SecretsMountHanaInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountHanaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountHanaObservation) DeepCopyInto(out *SecretsMountHanaObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountHanaObservation.
func (in *SecretsMountHanaObservation) DeepCopy() *SecretsMountHanaObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountHanaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountHanaParameters) DeepCopyInto(out *SecretsMountHanaParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountHanaParameters.
func (in *SecretsMountHanaParameters) DeepCopy() *SecretsMountHanaParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountHanaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountInfluxdbInitParameters) DeepCopyInto(out *SecretsMountInfluxdbInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountInfluxdbInitParameters.
func (in *SecretsMountInfluxdbInitParameters) DeepCopy() *SecretsMountInfluxdbInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountInfluxdbInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountInfluxdbObservation) DeepCopyInto(out *SecretsMountInfluxdbObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountInfluxdbObservation.
func (in *SecretsMountInfluxdbObservation) DeepCopy() *SecretsMountInfluxdbObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountInfluxdbObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountInfluxdbParameters) DeepCopyInto(out *SecretsMountInfluxdbParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.PemBundleSecretRef != nil {
		in, out := &in.PemBundleSecretRef, &out.PemBundleSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PemJSONSecretRef != nil {
		in, out := &in.PemJSONSecretRef, &out.PemJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountInfluxdbParameters.
func (in *SecretsMountInfluxdbParameters) DeepCopy() *SecretsMountInfluxdbParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountInfluxdbParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountInitParameters) DeepCopyInto(out *SecretsMountInitParameters) {
	*out = *in
	if in.AllowedManagedKeys != nil {
		in, out := &in.AllowedManagedKeys, &out.AllowedManagedKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACRequestKeys != nil {
		in, out := &in.AuditNonHMACRequestKeys, &out.AuditNonHMACRequestKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACResponseKeys != nil {
		in, out := &in.AuditNonHMACResponseKeys, &out.AuditNonHMACResponseKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]SecretsMountCassandraInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]SecretsMountCouchbaseInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DefaultLeaseTTLSeconds != nil {
		in, out := &in.DefaultLeaseTTLSeconds, &out.DefaultLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]SecretsMountElasticsearchInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExternalEntropyAccess != nil {
		in, out := &in.ExternalEntropyAccess, &out.ExternalEntropyAccess
		*out = new(bool)
		**out = **in
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]SecretsMountHanaInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]SecretsMountInfluxdbInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Local != nil {
		in, out := &in.Local, &out.Local
		*out = new(bool)
		**out = **in
	}
	if in.MaxLeaseTTLSeconds != nil {
		in, out := &in.MaxLeaseTTLSeconds, &out.MaxLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]SecretsMountMongodbInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]SecretsMountMongodbatlasInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]SecretsMountMssqlInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]SecretsMountMySQLInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]SecretsMountMySQLAuroraInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]SecretsMountMySQLLegacyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]SecretsMountMySQLRDSInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]SecretsMountOracleInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]SecretsMountPostgresqlInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]SecretsMountRedisInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]SecretsMountRedisElasticacheInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]SecretsMountRedshiftInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SealWrap != nil {
		in, out := &in.SealWrap, &out.SealWrap
		*out = new(bool)
		**out = **in
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SecretsMountSnowflakeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountInitParameters.
func (in *SecretsMountInitParameters) DeepCopy() *SecretsMountInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountList) DeepCopyInto(out *SecretsMountList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SecretsMount, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountList.
func (in *SecretsMountList) DeepCopy() *SecretsMountList {
	if in == nil {
		return nil
	}
	out := new(SecretsMountList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SecretsMountList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbInitParameters) DeepCopyInto(out *SecretsMountMongodbInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbInitParameters.
func (in *SecretsMountMongodbInitParameters) DeepCopy() *SecretsMountMongodbInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbObservation) DeepCopyInto(out *SecretsMountMongodbObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbObservation.
func (in *SecretsMountMongodbObservation) DeepCopy() *SecretsMountMongodbObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbParameters) DeepCopyInto(out *SecretsMountMongodbParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbParameters.
func (in *SecretsMountMongodbParameters) DeepCopy() *SecretsMountMongodbParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbatlasInitParameters) DeepCopyInto(out *SecretsMountMongodbatlasInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbatlasInitParameters.
func (in *SecretsMountMongodbatlasInitParameters) DeepCopy() *SecretsMountMongodbatlasInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbatlasInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbatlasObservation) DeepCopyInto(out *SecretsMountMongodbatlasObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbatlasObservation.
func (in *SecretsMountMongodbatlasObservation) DeepCopy() *SecretsMountMongodbatlasObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbatlasObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMongodbatlasParameters) DeepCopyInto(out *SecretsMountMongodbatlasParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	out.PrivateKeySecretRef = in.PrivateKeySecretRef
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMongodbatlasParameters.
func (in *SecretsMountMongodbatlasParameters) DeepCopy() *SecretsMountMongodbatlasParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMongodbatlasParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMssqlInitParameters) DeepCopyInto(out *SecretsMountMssqlInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMssqlInitParameters.
func (in *SecretsMountMssqlInitParameters) DeepCopy() *SecretsMountMssqlInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMssqlInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMssqlObservation) DeepCopyInto(out *SecretsMountMssqlObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMssqlObservation.
func (in *SecretsMountMssqlObservation) DeepCopy() *SecretsMountMssqlObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMssqlObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMssqlParameters) DeepCopyInto(out *SecretsMountMssqlParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.ContainedDB != nil {
		in, out := &in.ContainedDB, &out.ContainedDB
		*out = new(bool)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMssqlParameters.
func (in *SecretsMountMssqlParameters) DeepCopy() *SecretsMountMssqlParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMssqlParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLAuroraInitParameters) DeepCopyInto(out *SecretsMountMySQLAuroraInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLAuroraInitParameters.
func (in *SecretsMountMySQLAuroraInitParameters) DeepCopy() *SecretsMountMySQLAuroraInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLAuroraInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLAuroraObservation) DeepCopyInto(out *SecretsMountMySQLAuroraObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLAuroraObservation.
func (in *SecretsMountMySQLAuroraObservation) DeepCopy() *SecretsMountMySQLAuroraObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLAuroraObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLAuroraParameters) DeepCopyInto(out *SecretsMountMySQLAuroraParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLAuroraParameters.
func (in *SecretsMountMySQLAuroraParameters) DeepCopy() *SecretsMountMySQLAuroraParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLAuroraParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLInitParameters) DeepCopyInto(out *SecretsMountMySQLInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLInitParameters.
func (in *SecretsMountMySQLInitParameters) DeepCopy() *SecretsMountMySQLInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLLegacyInitParameters) DeepCopyInto(out *SecretsMountMySQLLegacyInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLLegacyInitParameters.
func (in *SecretsMountMySQLLegacyInitParameters) DeepCopy() *SecretsMountMySQLLegacyInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLLegacyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLLegacyObservation) DeepCopyInto(out *SecretsMountMySQLLegacyObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLLegacyObservation.
func (in *SecretsMountMySQLLegacyObservation) DeepCopy() *SecretsMountMySQLLegacyObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLLegacyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLLegacyParameters) DeepCopyInto(out *SecretsMountMySQLLegacyParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLLegacyParameters.
func (in *SecretsMountMySQLLegacyParameters) DeepCopy() *SecretsMountMySQLLegacyParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLLegacyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLObservation) DeepCopyInto(out *SecretsMountMySQLObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLObservation.
func (in *SecretsMountMySQLObservation) DeepCopy() *SecretsMountMySQLObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLParameters) DeepCopyInto(out *SecretsMountMySQLParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLParameters.
func (in *SecretsMountMySQLParameters) DeepCopy() *SecretsMountMySQLParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLRDSInitParameters) DeepCopyInto(out *SecretsMountMySQLRDSInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLRDSInitParameters.
func (in *SecretsMountMySQLRDSInitParameters) DeepCopy() *SecretsMountMySQLRDSInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLRDSInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLRDSObservation) DeepCopyInto(out *SecretsMountMySQLRDSObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLRDSObservation.
func (in *SecretsMountMySQLRDSObservation) DeepCopy() *SecretsMountMySQLRDSObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLRDSObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountMySQLRDSParameters) DeepCopyInto(out *SecretsMountMySQLRDSParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.TLSCA != nil {
		in, out := &in.TLSCA, &out.TLSCA
		*out = new(string)
		**out = **in
	}
	if in.TLSCertificateKeySecretRef != nil {
		in, out := &in.TLSCertificateKeySecretRef, &out.TLSCertificateKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountMySQLRDSParameters.
func (in *SecretsMountMySQLRDSParameters) DeepCopy() *SecretsMountMySQLRDSParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountMySQLRDSParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountObservation) DeepCopyInto(out *SecretsMountObservation) {
	*out = *in
	if in.Accessor != nil {
		in, out := &in.Accessor, &out.Accessor
		*out = new(string)
		**out = **in
	}
	if in.AllowedManagedKeys != nil {
		in, out := &in.AllowedManagedKeys, &out.AllowedManagedKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACRequestKeys != nil {
		in, out := &in.AuditNonHMACRequestKeys, &out.AuditNonHMACRequestKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACResponseKeys != nil {
		in, out := &in.AuditNonHMACResponseKeys, &out.AuditNonHMACResponseKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]SecretsMountCassandraObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]SecretsMountCouchbaseObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DefaultLeaseTTLSeconds != nil {
		in, out := &in.DefaultLeaseTTLSeconds, &out.DefaultLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]SecretsMountElasticsearchObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EngineCount != nil {
		in, out := &in.EngineCount, &out.EngineCount
		*out = new(float64)
		**out = **in
	}
	if in.ExternalEntropyAccess != nil {
		in, out := &in.ExternalEntropyAccess, &out.ExternalEntropyAccess
		*out = new(bool)
		**out = **in
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]SecretsMountHanaObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]SecretsMountInfluxdbObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Local != nil {
		in, out := &in.Local, &out.Local
		*out = new(bool)
		**out = **in
	}
	if in.MaxLeaseTTLSeconds != nil {
		in, out := &in.MaxLeaseTTLSeconds, &out.MaxLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]SecretsMountMongodbObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]SecretsMountMongodbatlasObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]SecretsMountMssqlObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]SecretsMountMySQLObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]SecretsMountMySQLAuroraObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]SecretsMountMySQLLegacyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]SecretsMountMySQLRDSObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]SecretsMountOracleObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]SecretsMountPostgresqlObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]SecretsMountRedisObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]SecretsMountRedisElasticacheObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]SecretsMountRedshiftObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SealWrap != nil {
		in, out := &in.SealWrap, &out.SealWrap
		*out = new(bool)
		**out = **in
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SecretsMountSnowflakeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountObservation.
func (in *SecretsMountObservation) DeepCopy() *SecretsMountObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountOracleInitParameters) DeepCopyInto(out *SecretsMountOracleInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountOracleInitParameters.
func (in *SecretsMountOracleInitParameters) DeepCopy() *SecretsMountOracleInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountOracleInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountOracleObservation) DeepCopyInto(out *SecretsMountOracleObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountOracleObservation.
func (in *SecretsMountOracleObservation) DeepCopy() *SecretsMountOracleObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountOracleObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountOracleParameters) DeepCopyInto(out *SecretsMountOracleParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisconnectSessions != nil {
		in, out := &in.DisconnectSessions, &out.DisconnectSessions
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SplitStatements != nil {
		in, out := &in.SplitStatements, &out.SplitStatements
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountOracleParameters.
func (in *SecretsMountOracleParameters) DeepCopy() *SecretsMountOracleParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountOracleParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountParameters) DeepCopyInto(out *SecretsMountParameters) {
	*out = *in
	if in.AllowedManagedKeys != nil {
		in, out := &in.AllowedManagedKeys, &out.AllowedManagedKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACRequestKeys != nil {
		in, out := &in.AuditNonHMACRequestKeys, &out.AuditNonHMACRequestKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuditNonHMACResponseKeys != nil {
		in, out := &in.AuditNonHMACResponseKeys, &out.AuditNonHMACResponseKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = make([]SecretsMountCassandraParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Couchbase != nil {
		in, out := &in.Couchbase, &out.Couchbase
		*out = make([]SecretsMountCouchbaseParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DefaultLeaseTTLSeconds != nil {
		in, out := &in.DefaultLeaseTTLSeconds, &out.DefaultLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]SecretsMountElasticsearchParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExternalEntropyAccess != nil {
		in, out := &in.ExternalEntropyAccess, &out.ExternalEntropyAccess
		*out = new(bool)
		**out = **in
	}
	if in.Hana != nil {
		in, out := &in.Hana, &out.Hana
		*out = make([]SecretsMountHanaParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Influxdb != nil {
		in, out := &in.Influxdb, &out.Influxdb
		*out = make([]SecretsMountInfluxdbParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Local != nil {
		in, out := &in.Local, &out.Local
		*out = new(bool)
		**out = **in
	}
	if in.MaxLeaseTTLSeconds != nil {
		in, out := &in.MaxLeaseTTLSeconds, &out.MaxLeaseTTLSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]SecretsMountMongodbParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodbatlas != nil {
		in, out := &in.Mongodbatlas, &out.Mongodbatlas
		*out = make([]SecretsMountMongodbatlasParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mssql != nil {
		in, out := &in.Mssql, &out.Mssql
		*out = make([]SecretsMountMssqlParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]SecretsMountMySQLParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLAurora != nil {
		in, out := &in.MySQLAurora, &out.MySQLAurora
		*out = make([]SecretsMountMySQLAuroraParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLLegacy != nil {
		in, out := &in.MySQLLegacy, &out.MySQLLegacy
		*out = make([]SecretsMountMySQLLegacyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQLRDS != nil {
		in, out := &in.MySQLRDS, &out.MySQLRDS
		*out = make([]SecretsMountMySQLRDSParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Oracle != nil {
		in, out := &in.Oracle, &out.Oracle
		*out = make([]SecretsMountOracleParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.Postgresql != nil {
		in, out := &in.Postgresql, &out.Postgresql
		*out = make([]SecretsMountPostgresqlParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]SecretsMountRedisParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedisElasticache != nil {
		in, out := &in.RedisElasticache, &out.RedisElasticache
		*out = make([]SecretsMountRedisElasticacheParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redshift != nil {
		in, out := &in.Redshift, &out.Redshift
		*out = make([]SecretsMountRedshiftParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SealWrap != nil {
		in, out := &in.SealWrap, &out.SealWrap
		*out = new(bool)
		**out = **in
	}
	if in.Snowflake != nil {
		in, out := &in.Snowflake, &out.Snowflake
		*out = make([]SecretsMountSnowflakeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountParameters.
func (in *SecretsMountParameters) DeepCopy() *SecretsMountParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountPostgresqlInitParameters) DeepCopyInto(out *SecretsMountPostgresqlInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountPostgresqlInitParameters.
func (in *SecretsMountPostgresqlInitParameters) DeepCopy() *SecretsMountPostgresqlInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountPostgresqlInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountPostgresqlObservation) DeepCopyInto(out *SecretsMountPostgresqlObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountPostgresqlObservation.
func (in *SecretsMountPostgresqlObservation) DeepCopy() *SecretsMountPostgresqlObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountPostgresqlObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountPostgresqlParameters) DeepCopyInto(out *SecretsMountPostgresqlParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceAccountJSONSecretRef != nil {
		in, out := &in.ServiceAccountJSONSecretRef, &out.ServiceAccountJSONSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountPostgresqlParameters.
func (in *SecretsMountPostgresqlParameters) DeepCopy() *SecretsMountPostgresqlParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountPostgresqlParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisElasticacheInitParameters) DeepCopyInto(out *SecretsMountRedisElasticacheInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisElasticacheInitParameters.
func (in *SecretsMountRedisElasticacheInitParameters) DeepCopy() *SecretsMountRedisElasticacheInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisElasticacheInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisElasticacheObservation) DeepCopyInto(out *SecretsMountRedisElasticacheObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisElasticacheObservation.
func (in *SecretsMountRedisElasticacheObservation) DeepCopy() *SecretsMountRedisElasticacheObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisElasticacheObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisElasticacheParameters) DeepCopyInto(out *SecretsMountRedisElasticacheParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UsernameSecretRef != nil {
		in, out := &in.UsernameSecretRef, &out.UsernameSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisElasticacheParameters.
func (in *SecretsMountRedisElasticacheParameters) DeepCopy() *SecretsMountRedisElasticacheParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisElasticacheParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisInitParameters) DeepCopyInto(out *SecretsMountRedisInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisInitParameters.
func (in *SecretsMountRedisInitParameters) DeepCopy() *SecretsMountRedisInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisObservation) DeepCopyInto(out *SecretsMountRedisObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisObservation.
func (in *SecretsMountRedisObservation) DeepCopy() *SecretsMountRedisObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedisParameters) DeepCopyInto(out *SecretsMountRedisParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CACert != nil {
		in, out := &in.CACert, &out.CACert
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.InsecureTLS != nil {
		in, out := &in.InsecureTLS, &out.InsecureTLS
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedisParameters.
func (in *SecretsMountRedisParameters) DeepCopy() *SecretsMountRedisParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedisParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedshiftInitParameters) DeepCopyInto(out *SecretsMountRedshiftInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedshiftInitParameters.
func (in *SecretsMountRedshiftInitParameters) DeepCopy() *SecretsMountRedshiftInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedshiftInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedshiftObservation) DeepCopyInto(out *SecretsMountRedshiftObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedshiftObservation.
func (in *SecretsMountRedshiftObservation) DeepCopy() *SecretsMountRedshiftObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedshiftObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountRedshiftParameters) DeepCopyInto(out *SecretsMountRedshiftParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisableEscaping != nil {
		in, out := &in.DisableEscaping, &out.DisableEscaping
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountRedshiftParameters.
func (in *SecretsMountRedshiftParameters) DeepCopy() *SecretsMountRedshiftParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountRedshiftParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountSnowflakeInitParameters) DeepCopyInto(out *SecretsMountSnowflakeInitParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountSnowflakeInitParameters.
func (in *SecretsMountSnowflakeInitParameters) DeepCopy() *SecretsMountSnowflakeInitParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountSnowflakeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountSnowflakeObservation) DeepCopyInto(out *SecretsMountSnowflakeObservation) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountSnowflakeObservation.
func (in *SecretsMountSnowflakeObservation) DeepCopy() *SecretsMountSnowflakeObservation {
	if in == nil {
		return nil
	}
	out := new(SecretsMountSnowflakeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountSnowflakeParameters) DeepCopyInto(out *SecretsMountSnowflakeParameters) {
	*out = *in
	if in.AllowedRoles != nil {
		in, out := &in.AllowedRoles, &out.AllowedRoles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.Data != nil {
		in, out := &in.Data, &out.Data
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PluginName != nil {
		in, out := &in.PluginName, &out.PluginName
		*out = new(string)
		**out = **in
	}
	if in.RootRotationStatements != nil {
		in, out := &in.RootRotationStatements, &out.RootRotationStatements
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
	if in.VerifyConnection != nil {
		in, out := &in.VerifyConnection, &out.VerifyConnection
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountSnowflakeParameters.
func (in *SecretsMountSnowflakeParameters) DeepCopy() *SecretsMountSnowflakeParameters {
	if in == nil {
		return nil
	}
	out := new(SecretsMountSnowflakeParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountSpec) DeepCopyInto(out *SecretsMountSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountSpec.
func (in *SecretsMountSpec) DeepCopy() *SecretsMountSpec {
	if in == nil {
		return nil
	}
	out := new(SecretsMountSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsMountStatus) DeepCopyInto(out *SecretsMountStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsMountStatus.
func (in *SecretsMountStatus) DeepCopy() *SecretsMountStatus {
	if in == nil {
		return nil
	}
	out := new(SecretsMountStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnowflakeInitParameters) DeepCopyInto(out *SnowflakeInitParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnowflakeInitParameters.
func (in *SnowflakeInitParameters) DeepCopy() *SnowflakeInitParameters {
	if in == nil {
		return nil
	}
	out := new(SnowflakeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnowflakeObservation) DeepCopyInto(out *SnowflakeObservation) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnowflakeObservation.
func (in *SnowflakeObservation) DeepCopy() *SnowflakeObservation {
	if in == nil {
		return nil
	}
	out := new(SnowflakeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnowflakeParameters) DeepCopyInto(out *SnowflakeParameters) {
	*out = *in
	if in.ConnectionURL != nil {
		in, out := &in.ConnectionURL, &out.ConnectionURL
		*out = new(string)
		**out = **in
	}
	if in.MaxConnectionLifetime != nil {
		in, out := &in.MaxConnectionLifetime, &out.MaxConnectionLifetime
		*out = new(float64)
		**out = **in
	}
	if in.MaxIdleConnections != nil {
		in, out := &in.MaxIdleConnections, &out.MaxIdleConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxOpenConnections != nil {
		in, out := &in.MaxOpenConnections, &out.MaxOpenConnections
		*out = new(float64)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.UsernameTemplate != nil {
		in, out := &in.UsernameTemplate, &out.UsernameTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnowflakeParameters.
func (in *SnowflakeParameters) DeepCopy() *SnowflakeParameters {
	if in == nil {
		return nil
	}
	out := new(SnowflakeParameters)
	in.DeepCopyInto(out)
	return out
}
